%
% Niniejszy plik stanowi przykład formatowania pracy magisterskiej na
% Wydziale MIM UW.  Szkielet użytych poleceń można wykorzystywać do
% woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie
% naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrzeżone.
%
% Copyright (c) 2001 by Marcin Woliński <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie 
% - Seweryn Karłowicz, 05.05.2006
% Dodanie wielu autorów i tłumaczenia na angielski - Kuba Pochrybniak, 29.11.2016

% dodaj opcję [licencjacka] dla pracy licencjackiej
% dodaj opcję [en] dla wersji angielskiej (mogą być obie: [licencjacka,en])
\documentclass[]{pracamgr}


% Dane magistranta:
\autor{Jakub Bujak}{370737}

\title{Logika separacji dla języka programowania Jafun}

%kierunek: 
% - matematyka, informacyka, ...
% - Mathematics, Computer Science, ...
\kierunek{informatyka}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% matematyka - zakres moze pozostac nieokreslony,
% a jesli ma byc okreslony dla pracy mgr,
% to przyjmuje jedna z wartosci:
% {metod matematycznych w finansach}
% {metod matematycznych w ubezpieczeniach}
% {matematyki stosowanej}
% {nauczania matematyki}
% Dla pracy licencjackiej mamy natomiast
% mozliwosc wpisania takiej wartosci zakresu:
% {Jednoczesnych Studiow Ekonomiczno--Matematycznych}

% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{dr hab. Aleksego Schuberta, prof. UW}

% miesiąc i~rok:
\date{Wrzesień 2020}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
%11.0 Matematyka, Informatyka:\\ 
%11.1 Matematyka\\ 
%11.2 Statystyka\\ 
11.3 Informatyka\\ 
%11.4 Sztuczna inteligencja\\ 
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{}

% Słowa kluczowe:
\keywords{Logika separacji, Jafun, weryfikacja}

% Tu jest dobre miejsce na Twoje własne makra i~środowiska:
\newtheorem{defi}{Definicja}[section]

\usepackage{amsmath}
\let\lll\undefined
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{amsthm}
% 
\newcommand \wand {\mathrel{-\mkern-6mu*}}
\newcommand \outerP {\mathbf{P}}
\newcommand \hoare [5] {\{#1\}#2\{#4.#5\}_#3}
\newcommand \prooflabel [1] {\LeftLabel{\scriptsize{\textsc{#1}}}}
\renewcommand \| {\hspace{0.75em} | \hspace{0.75em} }
\renewcommand \[ {[\![}
\renewcommand \] {]\!]}
\newcommand \eval [1] {\overset{#1}{\leadsto}}

\newtheorem{theorem}{Twierdzenie}
\newtheorem{lemma}{Lemat}

\theoremstyle{definition}
\newtheorem{definition}{Definicja}[section]

% koniec definicji

\begin{document}

\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
  W~pracy zdefiniowano logikę separacji dla języka Jafun, przedstawiono jej formalizację
  w~systemie Coq i~~udowoniono jej poprawność względem semantyki języka. Logika separacji pozwala
  na~podział sterty na rozłączne fragmenty. Upraszcza to~wnioskowanie o~programach, pozwalając
  na~dowodzenie własności podwyrażeń na~prostszych fragmentach sterty.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftablesC1 1 A

\chapter*{Wprowadzenie}
\addcontentsline{toc}{chapter}{Wprowadzenie}

\chapter{Podstawowe pojęcia i definicje}

\chapter{Jafun}

Jafun to~zorientowany obiektowo język programowania podobny do Javy.
Jego szczegółowy opis znajduje się w pracy \cite{jafun-def}.
Poniżej przedstawiam te aspekty języka, które są istotne dla prezentowanej logiki.


\section{Składnia i semantyka}

\section{Ewaluacja}
Ewaluacją konfiguracji $(h, st)$ będziemy nazywać dowolny ciąg par $\mathit{confs} = (h_1, st_1), \ldots, (h_n, st_n)$, taki że
$h_1 = h$, $st_1 = st$ oraz $(h_i, st_i) \rightarrow (h_{i+1}, st_{i+1})$ dla $1 \leq i < n$.

Ewaluacją wyrażenia $e$ na stercie $h$ będziemy nazywać taką ewaluację konfiguracji $(h, \[ e \]_\phi)$,
że $st_n = \[ l \]_A$ dla pewnych $l, A$. Jeśli taka ewaluacja istnieje, będziemy to oznaczać jako
$(h, e) \eval{confs} (h_n, A, l)$

\chapter{Składnia i semantyka}
Prezentowana logika separacji dla języka Jafun jest logiką z~kwantyfikatorami egzystencjalnymi pierwszego rzędu, trójkami Hoare'a, operatorem $\hookrightarrow$,
pozwalającym na opisywanie zawartości sterty i~operatorami separacji $*$ i $\wand$.

Iris, na~którym wzorowana jest niniejsza logika, jest afiniczną logiką separacyjną, to~znaczy
własność spełniania termu przez stertę jest domknięta ze względu na rozszerzanie sterty.
W celu zachowania zarówno afiniczności, jak i~poprawności względem semantyki
języka, prezentowana logika nie zawiera kwantyfikatora ogólnego,
a kwantyfikator egzystencjalny jest ograniczony
do~termów najwyższego poziomu (Rysunek \ref{fig:syntax}).

Używane będzie także oznaczenie $v_1 \neq v_2$ jako skrót dla $v_1 = v_2 \Rightarrow \mathtt{False}$.

\begin{figure}[h]
\begin{align*}
 \outerP ::= & \ \exists x : C.\outerP \| \outerP \wedge \outerP \| \outerP \vee \outerP \| P \\
 P ::= & \ \mathtt{True} \| \mathtt{False} \| P \wedge P \| P \vee P \| P \Rightarrow P \| v = v \| \\
     & \  v \hookrightarrow x = v \| \hoare{P}{e}{A}{x}{P} \|  P * P \| P \wand P \\
 v ::= & \  x \| \mathtt{null} \| \mathtt{this} \\
 A ::= & \ C \| \phi \\
 x ::= & \ \langle\mathit{identifier}\rangle \ (\mathit{variable / field\ name}) \\
 C ::= & \ \langle\mathit{identifier}\rangle \ (\mathit{class\ name}) \\
 e ::= & \ \langle \mathit{Jafun\ expression} \rangle
\end{align*}
\caption{Składnia logiki}
\label{fig:syntax}
\end{figure}

Środowisko to~funkcja częściowa przypisująca identyfikatorom lokacje na stercie lub \texttt{null}.
Semantyka logiki (Rysunek \ref{fig:sematics}) jest standardowa dla kwantyfikatora i operatorów logicznych.
Dla uproszczenia zapisu notacja $\[ \cdot \]$ została użyta do~opisu semantyki obu poziomów termów
($\outerP$ i $P$). To, do którego poziomu się odnosi, wynika z kontekstu.

Sterta spełnia trójkę Hoare'a $\hoare{P}{e}{A}{x}{Q}$, jeśli dla~każdej sterty spełniającej
$P$, wyrażenie $e$ zostanie obliczone bez błędu, zwróci wyjątek typu $A$ (czyli być może żaden),
a~wynikowa sterta będzie
spełniała $Q$, w którym za~$x$~podstawiony zostanie wynik obliczenia.

Sterta spełnia term $P * Q$, jeśli można ją podzielić na dwa rozłączne fragmenty, z których
jeden spełnia $P$, a drugi $Q$.
Operator $\wand$ to pewnego rodzaju odwrotność operatora $*$ -- sterta spełnia $P \wand Q$, jeśli
po połączeniu jej z dowolną rozłączną stertą spełniającą $P$, otrzymana sterta spełnia $Q$.

\begin{figure}
\begin{align*}
 \[ \texttt{True} \] \triangleq & \ \top \\
 \[ \texttt{False} \] \triangleq & \ \bot \\
 \[ \exists x : C . P \]_{h, env} \triangleq & \ \exists l : Loc\ .\ class(h, l) = C \wedge
    \[ P \]_{h, env[x \mapsto l]}  \\
 \[ P \wedge Q \]_{h, env} \triangleq & \ \[ P \]_{h, env} \wedge \[ Q \]_{h, env} \\
 \[ P \vee Q \]_{h, env} \triangleq & \ \[ P \]_{h, env} \vee \[ Q \]_{h, env} \\
 \[ P \Rightarrow Q \]_{h, env} \triangleq & \ \[ P \]_{h, env} \Rightarrow \[ Q \]_{h, env} \\
 % TODO this
 \[ x = y \]_{h, env} \triangleq & \ env(x) = env(y) \\
 \[ x \hookrightarrow f = y \]_{h, env} \triangleq & \ h(env(x))(f) = env(y) \\
 \[ \hoare{P}{e}{A}{x}{Q} \]_{h, env} \triangleq & \forall h : Heap \ . \ \[ P \]_{h, env} \Rightarrow \\
      & \ \  \exists h' : Heap, l : Loc \ . \ (h, e[/env]) \leadsto (h', A, l) \wedge
      \[ Q \]_{h', env[x \mapsto l]}  \\
 \[ P * Q \]_{h, env} \triangleq & \ \exists h_1,h_2 : Heap\ .\ h_1 \oplus h_2 = h \wedge
    \[ P \]_{h_1, env} \wedge \[ Q \]_{h2_, env}  \\
 \[ P \wand Q \]_{h, env} \triangleq & \forall h' : Heap \ . \ \[ P \]_{h', env} \Rightarrow \[ Q \]_{h \oplus h', env}
\end{align*}

Uwaga: $e[/env]$ oznacza wyrażenie powstałe przez~podstawienie $env[x]$ w~miejsce $x$ dla~każdej zmiennej
wolnej $x$ w~$e$.

\caption{Semantyka logiki}
\label{fig:sematics}
\end{figure}

\chapter{Reguły wnioskowania}
Osądy w prezentowanej logice są postaci $\Gamma | P \vdash Q$, gdzie $\Gamma$ to środowisko typów,
przypisujące zmiennym odpowiadające im typy (czyli nazwy klas), a $P$ i $Q$ to termy logiki.
Intuicyjnie, osąd $\Gamma | P \vdash Q$ oznacza że $Q$ wynika z $P$, a więc że każda sterta spełniająca
$P$ spełnia też $Q$.

Dla poprawienia czytelności, jeśli $\Gamma$ jest wspólne dla wszystkich osądów występujących
w danej regule, to jest ono pomijane.

% TODO założenie o otypowaniu P i Q


\begin{figure}[h]
\begin{center}
\AxiomC{\phantom{$Q$}}
\prooflabel{Asm}
\UnaryInfC{$P \vdash P$}
\DisplayProof
\hskip 2em
\AxiomC{$P \vdash Q$}
\AxiomC{$Q \vdash R$}
\prooflabel{Trans}
\BinaryInfC{$P \vdash R$}
\DisplayProof
\hskip 2em
\AxiomC{\phantom{$Q$}}
\prooflabel{Eq-refl}
\UnaryInfC{$P \vdash v = v$}
\DisplayProof
\hskip 2em
\AxiomC{$P \vdash v = w$}
\prooflabel{Eq-sym}
\UnaryInfC{$P \vdash w = v$}
\DisplayProof

\vskip 2em

\AxiomC{$P \vdash \mathtt{False}$}
\prooflabel{$\bot$E}
\UnaryInfC{$P \vdash Q$}
\DisplayProof
\hskip 2em
\AxiomC{\phantom{$Q$}}
\prooflabel{$\top$I}
\UnaryInfC{$P \vdash \mathtt{True}$}
\DisplayProof
\hskip 2em
\AxiomC{$R \vdash P$}
\AxiomC{$R \vdash Q$}
\prooflabel{$\wedge$I}
\BinaryInfC{$R \vdash P \wedge Q$}
\DisplayProof
\hskip 2em
\AxiomC{$R \vdash P \wedge Q$}
\prooflabel{$\wedge$EL}
\UnaryInfC{$R \vdash P$}
\DisplayProof

\vskip 2em

\AxiomC{$R \vdash P \wedge Q$}
\prooflabel{$\wedge$ER}
\UnaryInfC{$R \vdash Q$}
\DisplayProof
\hskip 2em
\AxiomC{$R \vdash P$}
\prooflabel{$\vee$IL}
\UnaryInfC{$R \vdash P \vee Q$}
\DisplayProof
\hskip 2em
\AxiomC{$R \vdash Q$}
\prooflabel{$\vee$IR}
\UnaryInfC{$R \vdash P \vee Q$}
\DisplayProof

\vskip 2em

\AxiomC{$S \vdash P \vee Q$}
\AxiomC{$P \vdash R$}
\AxiomC{$Q \vdash R$}
\prooflabel{$\vee$E}
\TrinaryInfC{$S \vdash R$}
\DisplayProof
\hskip 2em
\AxiomC{$R \wedge P \vdash Q$}
\prooflabel{$\Rightarrow$I}
\UnaryInfC{$R \vdash P \Rightarrow Q$}
\DisplayProof
\hskip 2em
\AxiomC{$R \vdash P \Rightarrow Q$}
\AxiomC{$R \vdash P$}
\prooflabel{$\Rightarrow$E}
\BinaryInfC{$R \vdash P \Rightarrow Q$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma, x : C | Q \vdash P[t / x]$}
\prooflabel{$\exists$I}
\UnaryInfC{$Q \vdash \exists x : C . P$}
\DisplayProof
\hskip 2em
\AxiomC{$\Gamma | R \vdash \exists x : C .  P$}
\AxiomC{$\Gamma, x : C | R \wedge P \vdash Q$}
\prooflabel{$\exists$E}
\BinaryInfC{$\Gamma  | R \vdash Q$}
\DisplayProof
\end{center}
\caption{Reguły wnioskowania dla tradycyjnych operatorów logicznych}
\end{figure}

\begin{figure}[h]
\begin{center}
\AxiomC{\phantom{$Q$}}
\prooflabel{Weak}
\UnaryInfC{$P * Q \vdash P$}
\DisplayProof
\hskip 2em
\AxiomC{\phantom{$Q$}}
\prooflabel{Sep-assoc}
\UnaryInfC{$P * (Q * R) \dashv\vdash (P * Q) * R$}
\DisplayProof
\hskip 2em
\AxiomC{\phantom{$Q$}}
\prooflabel{Sep-sym}
\UnaryInfC{$P * Q \vdash Q * P$}
\DisplayProof

\vskip 2em

\AxiomC{$P_1 \vdash Q_1$}
\AxiomC{$P_2 \vdash Q_2$}
\prooflabel{$*$I}
\BinaryInfC{$P_1 * Q_1 \vdash P_2 * Q_2$}
\DisplayProof
\hskip 2em
\AxiomC{$R * P \vdash Q$}
\prooflabel{$\wand$I}
\UnaryInfC{$R \vdash P \wand Q$}
\DisplayProof
\hskip 2em
\AxiomC{$R_1 \vdash P \wand Q$}
\AxiomC{$R_2 \vdash P$}
\prooflabel{$\wand$E}
\BinaryInfC{$R_1 * R_2 \vdash Q$}
\DisplayProof
\end{center}
\caption{Reguły wnioskowania dla operatorów separacyjnych}
\end{figure}


\begin{figure}
\begin{center}
\textbf{Reguły strukturalne dla trójek Hoare'a}

\vskip 2em

\AxiomC{$S \vdash \hoare{P}{e}{A}{v}{Q}$}
\AxiomC{$S$ jest trwały}
\prooflabel{Ht-frame}
\BinaryInfC{$S \vdash \hoare{P * R}{e}{A}{v}{Q * R}$}
\DisplayProof
\hskip 2em
\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-ret}
\UnaryInfC{$S \vdash \hoare{\mathtt{True}}{w}{\phi}{v}{v = w}$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma | S \vdash P \Rightarrow P'$}
\AxiomC{$\Gamma | S \vdash \hoare{P'}{e}{A}{v}{Q'}$}
\AxiomC{$\Gamma, v : C | S \vdash Q' \Rightarrow Q$}
\AxiomC{$S$ jest trwały}
\prooflabel{Ht-csq}
\QuaternaryInfC{$S \vdash \hoare{P}{e}{A}{v}{Q}$}
\DisplayProof

\vskip 2em

\AxiomC{$S \vdash \hoare{P}{e}{A}{v}{Q}$}
\AxiomC{$S \vdash \hoare{Q}{e}{A}{v}{Q}$}
\prooflabel{Ht-disj}
\BinaryInfC{$S \vdash \hoare{P \vee Q}{e}{A}{v}{Q}$}
\DisplayProof

\vskip 2em

\AxiomC{$S \wedge R \vdash \hoare{Q}{e}{A}{v}{Q}$}
\prooflabel{Ht-pers}
\RightLabel{jeśli R trwały}
\doubleLine
\UnaryInfC{$S \vdash \hoare{Q \wedge R}{e}{A}{v}{Q}$}
\DisplayProof

\vskip 2em

\textbf{Reguły dla trójek Hoare'a opisujących konstrukcje języka}

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-new-null}
\UnaryInfC{$S \vdash \hoare{\mathtt{True}}{\mathbf{new} \ C(\overline{v})}{\phi}{w}{w \neq \mathbf{null}}$}
\DisplayProof

\vskip 2em

\AxiomC{$\mathrm{flds}(C) = f_1, \ldots, f_n$}
\prooflabel{Ht-new-field}
\UnaryInfC{$S \vdash \hoare{\mathtt{True}}{\mathbf{new} \ C(v_1, \ldots, v_n)}{\phi}{w}{w \hookrightarrow f_i = v_i}$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma | S \vdash \hoare{P}{E_1}{\phi}{x}{Q}$}
\AxiomC{$\Gamma, x : C | S \vdash \hoare{Q}{E_2}{A}{w}{R}$}
\prooflabel{Ht-let}
\RightLabel{jeśli S trwały}
\BinaryInfC{$\Gamma | S \vdash \hoare{P}{\mathbf{let} \ C \ x = E_1 \ \mathbf{in} \ E_2}{A}{w}{R}$}
\DisplayProof

\vskip 2em

\AxiomC{$S \vdash \hoare{P}{E_1}{A}{w}{Q}$}
\AxiomC{$A \neq \phi$}
\prooflabel{Ht-let-ex}
\BinaryInfC{$\Gamma | S \vdash \hoare{P}{\mathbf{let} \ C \ x = E_1 \ \mathbf{in} \ E_2}{A}{w}{Q}$}
\DisplayProof

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-field-set}
\UnaryInfC{$S \vdash \hoare{x \neq \mathtt{null}}{x.f = v}{\phi}{\_}{x \hookrightarrow f = v}$}
\DisplayProof

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-null-set}
\UnaryInfC{$S \vdash \hoare{x = \mathtt{null}}{x.f = v}{\mathtt{NPE}}{w}{w = \mathtt{npe}}$}
\DisplayProof

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-field-get}
\UnaryInfC{$S \vdash \hoare{x \hookrightarrow f = v}{x.f}{\phi}{w}{w = v}$}
\DisplayProof

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-null-get}
\UnaryInfC{$S \vdash \hoare{x = \mathtt{null}}{x.f}{\mathtt{NPE}}{w}{w = \mathtt{npe}}$}
\DisplayProof
\end{center}
\caption{Reguły wnioskowania dla trójek Hoare'a}
\end{figure}


\begin{figure}
\begin{center}
\AxiomC{$S \vdash \hoare{P \wedge v_1 = v_2}{E_1}{A}{w}{Q}$}
\AxiomC{$S \vdash \hoare{P \wedge v_1 \neq v_2}{E_2}{A}{w}{Q}$}
\prooflabel{Ht-if}
\BinaryInfC{$S \vdash \hoare{P}{\mathbf{if} \ v_1 = v_2 \ \mathbf{then} \ E_1 \ \mathbf{else} \ E_2}{A}{w}{Q}$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma \vdash x : C$}
\AxiomC{$\hoare{P'}{\cdot}{A}{w}{Q'} \in \mathtt{invariants}(C, m)$}
\noLine
\UnaryInfC{$S \wedge \hoare{P'}{x.m(\overline{v})}{A}{w}{Q'} \vdash \hoare{P}{x.m(\overline{v})}{A}{w}{Q}$}
\prooflabel{Ht-invoke}
\BinaryInfC{$S \vdash \hoare{P}{x.m(\overline{v})}{A}{w}{Q}$}
\DisplayProof

\vskip 2em


\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-null-invoke}
\UnaryInfC{$S \vdash \hoare{x = \mathtt{null}}{x.m(\overline{v})}{\mathtt{NPE}}{w}{w = \mathtt{npe}}$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma \vdash x : C$}
\prooflabel{Ht-throw}
\UnaryInfC{$S \vdash \hoare{x \neq \mathtt{null}}{\mathbf{throw} \ x}{C}{w}{w = x}$}
\DisplayProof

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-null-throw}
\UnaryInfC{$S \vdash \hoare{x = \mathtt{null}}{\mathbf{throw} \ x}{\mathtt{NPE}}{w}{w = \mathtt{npe}}$}
\DisplayProof

\vskip 2em

\AxiomC{$S \vdash \hoare{P}{E_1}{\phi}{w}{Q}$}
\prooflabel{Ht-catch-normal}
\UnaryInfC{$S \vdash \hoare{P}{\mathbf{try} \ E_1 \ \mathbf{catch} \ (C \ x) \ E_2}{\phi}{w}{Q}$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma | S \vdash \hoare{P}{E_1}{C'}{x}{Q}$}
\AxiomC{$\Gamma, x : C' | S \vdash \hoare{Q}{E_2}{A}{w}{R}$}
\AxiomC{$C' \leq C$}
\prooflabel{Ht-catch-ex}
\RightLabel{jeśli S trwały}
\TrinaryInfC{$\Gamma | S \vdash \hoare{P}{\mathbf{try} \ E_1 \ \mathbf{catch} \ (C \ x) \ E_2}{A}{w}{R}$}
\DisplayProof

\vskip 2em

\AxiomC{$S \vdash \hoare{P}{E_1}{C'}{w}{Q}$}
\AxiomC{$C' \not\leq C$}
\prooflabel{Ht-catch-pass}
\BinaryInfC{$S \vdash \hoare{P}{\mathbf{try} \ E_1 \ \mathbf{catch} \ (C \ x) \ E_2}{C'}{w}{Q}$}
\DisplayProof


\caption{Reguły wnioskowania dla trójek Hoare'a - c.d.}
\end{center}
\end{figure}



\chapter{Własności ewaluacji}
Pokażę teraz twierdzenia o własności ewaluacji, które będą później użyte do udowodnienia poprawności reguł dla trójek Hoare'a.
\section{Łączenie ewaluacji}
Podatwowym twierdzeniem, pozwalającym mówić o ewaluacji złożonych wyrażeń, jest twierdzenie o łączeniu ewaluacji.
\begin{theorem}[O łączeniu ewaluacji]
Niech $(h, st), (h', st'), (h'', st'')$ będą konfiguracjami, a $confs$ i $confs'$ -- ciągami konfiguracji,
takimi że $(h, st) \eval{confs} (h', st')$ i $(h', st') \eval{confs'} (h'', st'')$.
Wtedy $(h, st) \eval{confs ++ confs'} (h'', st'')$.
\end{theorem}
\begin{proof}
TODO
\end{proof}

\section{Ewaluacja przy rozszerzonym stosie i kontekście}

\section{Ewaluacja zależy tylko od zmiennych wolnych}
Twierdzenie o zależności ewaluacji od zmiennych wolnych jest kluczowe w dowodzie poprawności dla
reguł \textsc{Weak} i \textsc{Ht-frame}.
Mówi ono, że jeśli dwie sterty zgadzają się na lokacjach odpowiadających zmiennym wolnym w pewnym wyrażeniu $E$,
to ewaluacje wyrażenia $E$ na tych dwóch stertach będą w pewnym sensie równoważne.

Równoważnośc ta nie będzie niestety trywialna, bo nowo zaalokowane lokacje na obu sterach mogą się różnić.
Zgodnie z semantyką języka, lokacja zwracana przez operator \textbf{new} to (maximum z lokacji na stercie) + 1.
Stąd, ponieważ nie zakładamy niczego o lokacjach innych niż te odpowiadające zmiennym wolnym,
wartość zwracana przez operator \textbf{new} może się różnić pomiędzy stertami.
Nowo zaalokowane lokacje mogą następnie zostać zapisane w polach obiektów znajdujących się pod lokacjami
odpowiadającymi zmiennym wolnym, co oznacza że nawet te obiekty, początkowo równe na obu stertach,
mogą zacząć się różnić w czasie ewaluacji.

Żeby obejść ten problem, zdefiniujemy \textit{izomorfizm stert} jako bijekcję między lokacjami
na tych stertach,
zachowującą \texttt{null} i kompozycję.

\begin{definition}[izomorfizm stert] {\ } \\
Niech $h_1, h_2 : \mathsf{Heap}$.
Funkcję $f : \mathrm{Dom}(h_1) \cup \{\mathtt{null}\} \to \mathrm{Dom}(h_2) \cup \{\mathtt{null}\}$
nazwiemy izomorfizmem między tymi stertami, jeśli:
\begin{enumerate}
 \item $f$ jest bijekcją
 \item $f(\mathtt{null}) = \mathtt{null}$
 \item $f$ zachowuje kompozycję, to znaczy dla dowolnych lokacji $l_1, l_2$ i pola $x$ zachodzi
    $$h_1(l_1) \hookrightarrow x = l_2 \iff h_2(f(l_2)) \hookrightarrow x = f(l_2)$$
\end{enumerate}
Jeśli taka funkcja $f$ istnieje, powiemy że sterty $h_1$ i $h_2$ są izomorficzne.
\qed
\end{definition}

Ostatecznie będziemy chcieli pokazać, że jeśli wyrażenie $E$ nie zawiera zmiennych wolnych,
a sterty $h_1, h_2$ są równe na wszystkich lokacjach występujących w $E$, to
ewaluacje $E$ na stertach $h_1$ i $h_2$ są równoważne z dokładnością do izomorfizmu.

To oznacza, że potrzebujemy mówić o izomorfizmach konfiguracji (czyli ciągów par (sterta, stos wywołań)),
a zatem należy zdefiniować także izomorfizmy między stosami wywołań.
Służy temu kolejnych kilka definicji.


\chapter{Poprawność}

\chapter{Formalizacja w systemie Coq}

\chapter{Podsumowanie}

\appendix
\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem {jafun-def} J. Chrząszcz and A. Schubert. Function definitions for compound values in object-
oriented languages. In \textit{Proc. of the 19th International Symposium on Principles
and Practice of Declarative Programming}, PPDP ’17, pp. 61–72. ACM, 2017.

\bibitem {jafun-sem} J. Chrząszcz and A.Schubert. Formalisation of a frame stack semantics for a Java-like language. 2018

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
