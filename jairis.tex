%
% Niniejszy plik stanowi przykład formatowania pracy magisterskiej na
% Wydziale MIM UW.  Szkielet użytych poleceń można wykorzystywać do
% woli, np. formatujac wlasna prace.
%
% Zawartosc merytoryczna stanowi oryginalnosiagniecie
% naukowosciowe Marcina Wolinskiego.  Wszelkie prawa zastrzeżone.
%
% Copyright (c) 2001 by Marcin Woliński <M.Wolinski@gust.org.pl>
% Poprawki spowodowane zmianami przepisów - Marcin Szczuka, 1.10.2004
% Poprawki spowodowane zmianami przepisow i ujednolicenie 
% - Seweryn Karłowicz, 05.05.2006
% Dodanie wielu autorów i tłumaczenia na angielski - Kuba Pochrybniak, 29.11.2016

% dodaj opcję [licencjacka] dla pracy licencjackiej
% dodaj opcję [en] dla wersji angielskiej (mogą być obie: [licencjacka,en])
\documentclass[]{pracamgr}


% Dane magistranta:
\autor{Jakub Bujak}{370737}

\title{Logika separacji dla języka programowania Jafun}

%kierunek: 
% - matematyka, informacyka, ...
% - Mathematics, Computer Science, ...
\kierunek{informatyka}

% informatyka - nie okreslamy zakresu (opcja zakomentowana)
% matematyka - zakres moze pozostac nieokreslony,
% a jesli ma byc okreslony dla pracy mgr,
% to przyjmuje jedna z wartosci:
% {metod matematycznych w finansach}
% {metod matematycznych w ubezpieczeniach}
% {matematyki stosowanej}
% {nauczania matematyki}
% Dla pracy licencjackiej mamy natomiast
% mozliwosc wpisania takiej wartosci zakresu:
% {Jednoczesnych Studiow Ekonomiczno--Matematycznych}

% \zakres{Tu wpisac, jesli trzeba, jedna z opcji podanych wyzej}

% Praca wykonana pod kierunkiem:
% (podać tytuł/stopień imię i nazwisko opiekuna
% Instytut
% ew. Wydział ew. Uczelnia (jeżeli nie MIM UW))
\opiekun{dr hab. Aleksego Schuberta, prof. UW}

% miesiąc i~rok:
\date{Wrzesień 2020}

%Podać dziedzinę wg klasyfikacji Socrates-Erasmus:
\dziedzina{ 
%11.0 Matematyka, Informatyka:\\ 
%11.1 Matematyka\\ 
%11.2 Statystyka\\ 
11.3 Informatyka\\ 
%11.4 Sztuczna inteligencja\\ 
%11.5 Nauki aktuarialne\\
%11.9 Inne nauki matematyczne i informatyczne
}

%Klasyfikacja tematyczna wedlug AMS (matematyka) lub ACM (informatyka)
\klasyfikacja{}

% Słowa kluczowe:
\keywords{Logika separacji, Jafun, weryfikacja}

% Tu jest dobre miejsce na Twoje własne makra i~środowiska:
\newtheorem{defi}{Definicja}[section]

\usepackage{amsmath}
\let\lll\undefined
\usepackage{amssymb}
\usepackage{bussproofs}
\usepackage{amsthm}
% 
\newcommand \wand {\mathrel{-\mkern-6mu*}}
\newcommand \outerP {\mathbf{P}}
\newcommand \hoare [5] {\{#1\}#2\{#4.#5\}_#3}
\newcommand \prooflabel [1] {\LeftLabel{\scriptsize{\textsc{#1}}}}
\renewcommand \| {\hspace{0.75em} | \hspace{0.75em} }
\renewcommand \[ {[\![}
\renewcommand \] {]\!]}
\newcommand \eval [1] {\overset{#1}{\leadsto}}

\newtheorem{theorem}{Twierdzenie}
\newtheorem{lemma}{Lemat}

\theoremstyle{definition}
\newtheorem{definition}{Definicja}[section]


\usepackage[lighttt]{lmodern}
\usepackage{amssymb}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
%\usepackage{amssymb}
%\usepackage{alltt}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{graphicx}
%\usepackage{caption,subcaption}
\usepackage{fancyvrb}
%\usepackage{graphicx}
\usepackage{longtable}
%\usepackage{fancyhdr}
\usepackage{comment}
\usepackage{xspace}
\usepackage{url}
\usepackage{ifdraft}
\usepackage[final]{listings}
\usepackage{enumerate}
\usepackage{endnotes}
\usepackage[pdftex,bookmarks=true]{hyperref}
\usepackage{wrapfig}
%\ifdraft{\usepackage[right]{showlabels}}{} %works only after hyperref
% powyzsze musi byc w \ifdraft, bo wpp nie znikaja label'e przy
% equation :) - taki bug

%%%%%%% generic definitions
\newcommand{\draft}[1]{\ifdraft{{\color{red} [[[#1]]]}}{} }
\newcommand{\draftmargin}[1]{\ifdraft{\marginpar{\parbox{2cm}{\color{red}\raggedright\small
        #1}}}{\ignorespaces}}
\newcommand{\alxnote}[1]{\ifdraft{\marginpar{\parbox{2cm}{\color{red}\raggedright\small alx: #1}}}{\ignorespaces}}
\newcommand{\infomargin}[1]{\ifdraft{\marginpar{\parbox{2cm}{\color{blue}\raggedright\small #1}}}{\ignorespaces}}
\ifdraft{\DefineVerbatimEnvironment{draftverbatim}{Verbatim}{formatcom=\color{red}}}{\specialcomment{draftverbatim}{}{}\excludecomment{draftverbatim}}
\newcommand{\dremph}[1]{\ifdraft{{\color{red}#1}\xspace}{#1\xspace}}
\newcommand{\draddbookmark}[1]{\ifdraft{\phantomsection\addcontentsline{toc}{subsubsection}{#1}}{\ignorespaces}}

%%%%%%% definitions specific for the paper
\newcommand{\mint}{\textsf{int}}
\newcommand{\mboolean}{\textsf{boolean}}
\newcommand{\float}{\textsf{float}}
\newcommand{\byte}{\textsf{byte}}
\newcommand{\mchar}{\textsf{char}}
\newcommand{\mlong}{\textsf{long}}
\newcommand{\double}{\textsf{double}}
\newcommand{\OurArray}{\textsf{OurArray}}
\newcommand{\String}{\textsf{String}}
\newcommand{\Char}{\textsf{Char}}
\newcommand{\ar}{\mathit{ar}\xspace}
\newcommand{\jpublic}{\mathsf{public}\xspace}
\newcommand{\jprotected}{\mathsf{protected}\xspace}
\newcommand{\jprivate}{\mathsf{private}\xspace}
\newcommand{\jfinal}{\mathsf{final}\xspace}
\newcommand{\Jafun}{\textsl{Jafun}\xspace}
\newcommand{\Jimuva}{\textsl{Jimuva}\xspace}
\newcommand{\ls}{\mathtt{rwr}\xspace}
\newcommand{\lenv}{\mathtt{rd}\xspace}
\newcommand{\bb}{\mathtt{atm}\xspace}

% \makeatletter
% \newtheorem{df@}{Definition}
% %\newtheorem{theorem@}{Theorem}
% \newtheorem{lemma@}[theorem@]{Lemma}
% \newenvironment{theorem}[1]%
%   {\begin{theorem@}{\tt (#1)}\mbox{}\\}%
%   {\end{theorem@}}
% \newtheorem{prop@}[theorem@]{Proposition}
% \newenvironment{proposition}[1]%
%   {\begin{prop@}{\tt (#1)}\mbox{}\\}%
%   {\end{prop@}}
% \newenvironment{lemma}[1]%
%   {\begin{lemma@}{\tt (#1)}\mbox{}\\}%
%   {\end{lemma@}}
% \newtheorem{example@}{Example}%
% \newenvironment{example}%
%   {\begin{example@}\upshape}%
%   {\end{example@}}
% 
% \newenvironment{df}[1]%
%   {\begin{df@}{\tt (#1)}\rm\mbox{}\\}%
%   {\end{df@}}
% \newtheorem{fact@}{Fact}[section]
% \newtheorem{col@}[fact@]{Corollary}
% \newenvironment{co}[1]%
%   {\begin{col@}{\tt (#1)}\mbox{}\\}%
%   {\end{col@}}
\newcommand{\world}{\mathsf{world}}
\newcommand{\rawty}{\mathsf{rawty}}
\newcommand{\state}{\mathsf{state}}
% \def\sqr#1#2{\vbox%{\vcenter{\vbox%
%  {\hrule height#2
%   \hbox{\vrule width#2 height#1 \kern#1 \vrule width#2}%
%   \hrule height#2}}%}}
% \def\squarek{\sqr{1.5ex}{.4pt}}
% \def\koniec{\mbox{}%\hspace{20pt}
% \nolinebreak[4]{\mbox{}\hspace*{20pt}\hfill\squarek}}
% \newenvironment{proof}{\vspace*{-0.8em}\noindent{\bf
%     Proof:\\}}{\koniec\par\vspace*{-\parskip}}
% \newenvironment{proofof}[1]{\noindent{\bf
%     Proof` #1:\\}}{\koniec}
\newcommand{\ClassId}{\mathsf{ClassId}\xspace}
\newcommand{\FieldId}{\mathsf{FieldId}\xspace}
\newcommand{\MethId}{\mathsf{MethId}\xspace}
\newcommand{\ConsId}{\mathsf{ConsId}\xspace}
\newcommand{\ObjId}{\mathsf{ObjId}\xspace}
\newcommand{\Var}{\mathsf{Var}\xspace}
\newcommand{\immutable}{\mathbb{I}\xspace}
\newcommand{\func}{\mathbb{F}\xspace}
\newcommand{\fresh}{\mathbb{H}\xspace}

\newcommand{\ThrOK}{\mathsf{ThrOK}\xspace}

% \newcommand{\void}{\mathsf{void}\xspace}
% \newcommand{\class}{\mathsf{class}\xspace}
% \newcommand{\ext}{\mathsf{ext}\xspace}
% \newcommand{\myowner}{\mathsf{myowner}\xspace}
% \newcommand{\Val}{\mathsf{Val}\xspace}
% \newcommand{\ValTy}{\mathsf{ValTy}\xspace}
\newcommand{\Object}{\mathsf{Object}\xspace}
\newcommand{\new}{\mathsf{new}\xspace}
% \newcommand{\mlet}{\mathsf{let}\xspace}
% \newcommand{\myin}{\mathsf{in}\xspace}
% \newcommand{\Nianio}{\textsf{Nianio}\xspace}
\newcommand{\Obj}{\textsf{Obj}\xspace}
% \newcommand{\fd}{\mathsf{fd}\xspace}

\newcommand{\ok}{\mathsf{ok}\xspace}

\newcommand{\pure}{\textsf{pure}\xspace}
\newcommand{\maybevdash}{\vdash^? }
\newcommand{\typeof}{\mathsf{typeof}}

\newcommand{\Nat}{\mathsf{Nat}}

\newcommand{\dsrul}[1]{\hypertarget{srul-#1}{\textrm{(#1)}}} %semantic rules, np (ifnpe)
\newcommand{\srul}[1]{\hyperlink{srul-#1}{\textrm{(#1)}}} %semantic rules, np (ifnpe)
%\newcommand{\srul}[1]{\textrm{(#1)}\xspace} %semantic rules, np (ifnpe)
%\newcommand{\trul}[1]{{\rm (#1)}\xspace} %typing rules, np (ifnpe)
\newcommand{\dtrul}[1]{\hypertarget{trul-#1}{\raisebox{0.2ex}{\rm \scriptsize
    (}\textsc{#1}\raisebox{0.2ex}{\rm \scriptsize )}}}
\newcommand{\trul}[1]{\hyperlink{trul-#1}{\raisebox{0.2ex}{\rm \scriptsize
    (}\textsc{#1}\raisebox{0.2ex}{\rm \scriptsize )}}}
%\newcommand{\dtrul}[1]{\hypertarget{#1}{\sc #1}}
%\newcommand{\rtrul}[1]{\hyperlink{#1}{\sc #1}}

\newcommand{\exheap}[2]{\stackrel{#1}{#2}} % #1 - czas, #2 - heap
\newcommand{\len}[1]{\mathsf{len}(#1)\xspace}
\newcommand{\abs}[1]{|#1|\xspace}
\renewcommand{\P}{\mathcal{P}}
\newcommand{\myparagraph}[1]{\smallskip\noindent\emph{#1\;}}

\newcommand{\class}{\mathrm{class}}
\newcommand{\meth}{\mathrm{meth}}
\newcommand{\exc}{\mathrm{exc}}
\newcommand{\loc}{\mathrm{loc}}
\newcommand{\expr}{\mathrm{expr}}
\newcommand{\this}{\mathrm{this}}
\newcommand{\lexc}{\mathrm{lexc}}
\newcommand{\type}{\mathrm{type}}
\renewcommand{\mod}{\mathrm{mod}}
\newcommand{\ltsub}{<:}

%nonterminals
\newcommand{\cdecl}{\mathsf{cdecl}\xspace}
\newcommand{\cmodifier}{\varsigma\xspace}
\newcommand{\mmod}{\mu\xspace}
\newcommand{\kmodifier}{\kappa\xspace}
\newcommand{\fmodifier}{\phi\xspace}
\newcommand{\argone}{\mathsf{arg}\xspace}
\newcommand{\argonen}{\mathsf{argn}\xspace}
\newcommand{\args}{\overline{\mathsf{arg}}\xspace}
\newcommand{\argns}{\overline{\mathsf{argn}}\xspace}
\newcommand{\Ex}{\mathsf{Exc}\xspace}
\newcommand{\Exn}{\mathsf{Excn}\xspace}
\newcommand{\Exc}{\overline{\mathsf{Exc}}\xspace}
\newcommand{\Excn}{\overline{\mathsf{Excn}}\xspace}
\newcommand{\fieldref}{\mathsf{fieldref}\xspace}
\newcommand{\varref}{\mathsf{v}\xspace}
\newcommand{\varrefs}{\overline{\varref}}

%terminals
\newcommand{\jclass}{\mathbf{class}\xspace}
\newcommand{\jext}{\mathbf{ext}\xspace}


\newcommand{\reg}{\emptyset}
\newcommand{\rep}{\mathtt{rep}\xspace}
\newcommand{\throws}{\mathbf{throws}\xspace}
\newcommand{\jlet}{\mathbf{let}\xspace}
\newcommand{\jin}{\mathbf{in}\xspace}
\newcommand{\jif}{\mathbf{if}\xspace}
\newcommand{\jthen}{\mathbf{then}\xspace}
\newcommand{\jelse}{\mathbf{else}\xspace}
\newcommand{\jthrow}{\mathbf{throw}\xspace}
\newcommand{\jtry}{\mathbf{try}\xspace}
\newcommand{\jcatch}{\mathbf{catch}\xspace}
\newcommand{\jnull}{\mathbf{null}\xspace}
\newcommand{\jnew}{\mathbf{new}\xspace}
\newcommand{\jthis}{\textbf{this}\xspace}
\newcommand{\letin}[4]{\jlet\; #1\; #2 = #3\; \jin\; #4\xspace}
\newcommand{\ite}[3]{\jif\; #1\; \jthen\; #2\; \jelse\; #3\xspace}
\newcommand{\newin}[3]{\jnew\; #1\; #2(#3)\xspace}
\newcommand{\throwin}[1]{\jthrow\; #1\xspace}
\newcommand{\tcatch}[4]{\jtry\; \boldsymbol{\{}#1\boldsymbol{\}}\; \jcatch\; (#2\; #3)\; \boldsymbol{\{}#4\boldsymbol{\}}\xspace}

%other definitions
\newcommand{\Cname}{\mathsf{CId}\xspace}
\newcommand{\Lannot}{\mathsf{AMod}\xspace}
\newcommand{\Lannott}{\mathsf{AMod}^\dagger\xspace}
%\newcommand{\Val}{\mathsf{Val}\xspace}
\newcommand{\Ident}{\mathsf{Id}\xspace}
\newcommand{\MIdent}{\mathsf{MId}\xspace}
%\newcommand{\KIdent}{\mathsf{KId}\xspace}
%\newcommand{\Obj}{\mathsf{Obj}\xspace}
\newcommand{\Expr}{\mathsf{Expr}\xspace}
\newcommand{\BCtxt}{\mathsf{BCtxt}\xspace}
\newcommand{\Stacks}{\mathsf{Stacks}\xspace}

\newcommand{\Loc}{\mathsf{Loc}\xspace}
\newcommand{\Heap}{\mathsf{Heap}\xspace}
\newcommand{\ctxt}{\mathcal{C}\xspace}
\newcommand{\alloc}{\mathsf{alloc}\xspace}
\newcommand{\Prog}{\mathsf{Prog}\xspace}
\newcommand{\body}{\mathsf{body}\xspace}
\newcommand{\classof}{\mathsf{class}\xspace}
\newcommand{\specof}{\mathsf{spec}\xspace}
\newcommand{\methods}{\mathsf{mthds}\xspace}
\newcommand{\konstructors}{\mathsf{knstr}\xspace}
\newcommand{\fields}{\mathsf{flds}\xspace}
\newcommand{\extends}{\mathsf{ext}\xspace}
\newcommand{\throwsset}{\mathsf{thrs}\xspace}
\newcommand{\params}{\mathsf{pars}\xspace}
\newcommand{\paramNames}{\mathsf{parNms}\xspace}
\newcommand{\paramTypeMod}{\mathsf{parTypM}\xspace}
\newcommand{\paramMod}{\mathsf{parMod}\xspace}
\newcommand{\returnTypeM}{\mathsf{retTypM}\xspace}
\newcommand{\isImmutable}{\mathsf{isImmutable}\xspace}
\newcommand{\isLocalSensitive}{\mathsf{isLS}\xspace}
\newcommand{\isFunctional}{\mathsf{isFUN}\xspace}
\newcommand{\lequpto}[1]{\sqsubseteq_{#1}}
\newcommand{\Rep}{\mathsf{Rep}\xspace}
\newcommand{\Repm}{\mathsf{Rep}^-\xspace}
\newcommand{\annot}[2]{{#1}(#2)\xspace}
\newcommand{\dotcup}{\hbox{$\cup\hspace{-1.08ex}\cdot\hspace{0.5ex}$}\xspace}
\newcommand{\name}{\mathsf{name}\xspace}

\newcommand{\parfunc}{\rightharpoonup}
\newcommand{\emptyclass}[1]{\mathsf{empty}_{#1}\xspace}
\newcommand{\dom}[1]{\mathsf{Dom}(#1)\xspace}
% \newcommand{\npetype}{\texttt{NullPointerException}\xspace} % za dluuuugie
\newcommand{\npetype}{\texttt{NPE}\xspace}
\newcommand{\exceptiontype}{\texttt{Exception}\xspace}
\newcommand{\objecttype}{\texttt{Object}\xspace}
\newcommand{\npe}{\mathsf{npe}\xspace}
\newcommand{\partoenv}{\mathsf{par2env}\xspace}
\newcommand{\partoloc}{\mathsf{loc2env}\xspace}

\newcommand{\subok}{\mathsf{subok}\xspace}

%ładny underscore (ukradzione z ocamlweb)
%\def\_{\kern.08em\vbox{\hrule width.35em height.6pt}\kern.08em}
% z jakiegoś powodu lst na to nie reaguje :(


\lstdefinelanguage{Jafun}{
  language=Java,
  basicstyle=\small\ttfamily\upshape,
  keywordstyle=\bfseries\ttfamily\small,
morekeywords={rd,rwr,atm,rep,peer,readonly,let,in,Pure,Fresh,accessible,assignable,mutable,polyread,readable,writable,immutable,isolated},
%  numbers=left,
%  numberstyle=\tiny\ttfamily,
  escapeinside=||,
}

\lstdefinelanguage{Coq}%
{morekeywords={Variable,Section,Inductive,CoInductive,Fixpoint,CoFixpoint,Declare,%
    Definition,Lemma,Theorem,Axiom,Local,Save,Grammar,Syntax,intro,Eval,comput
e,%
      trivial,Qed,intros,decompose,and,symmetry,admit,simpl,rewrite,Resolve,apply,elim,assumption,%
      left,cut,case,auto,intuition,forall,fun,unfold,exact,right,Hypothesis,patt
ern,destruct,eqn,%
      constructor,Defined,fix,Record,Proof,induction,Hints,exists,let,in,%
      Parameter,split,reflexivity,transitivity,if,then,else,Opaque,%
      Transparent,inversion,inversion_clear,absurd,generalize,Mutual,match,of,en
d,Analyze,struct,Ltac,%
      with,by,as,Mutual,Rewall,Set,Prop,Type,%
      Module,Import,End,Time,Require,Open,Scope,Export,repeat,Extraction,Notation,return,%
      AutoRewrite,Functional,Scheme,params,refine,using,discriminate,try,eapply,assert,case_eq,context},%
   sensitive,%
   keywordstyle=\bfseries,
   basicstyle=\small\slshape,
   morecomment=[n]{(*}{*)}, %dłuższe muszą być potem
   literate={:=}{{$:=$}}1 
{'}{'}0
{|}{{$\!\vert$}}1 
{|-}{{$\vdash$}}1 
{<-}{{$\!\leftarrow\!$}}1 
{->}{{$\;\rightarrow\;$}}1 
{=>}{{$\Rightarrow\;$}}1 
{/\\}{{$\land\;$}}1 
{\\/}{{$\lor\;$}}1 
{::}{\,{::}\;}1 
{<->}{{$\leftrightarrow$}}1
{[}{{$[$}}1 
{_}{{\tiny\_}}1
{_[}{{{\tiny\_}$[\,$}}1 
{[[}{{$\,[\,[\,$}}1 
{_[[_}{{{\tiny\_}$[\,[${\tiny\_}}}2 
{]}{{$]$}}1
{]_}{{$\;]${\tiny\_}}}1
{]]}{{$\,]\,]$}}2
{]]_}{{$\,]\,]${\tiny\_}}}2 
{_]]_}{{{\tiny\_}$]\,]${\tiny\_\ }}}2
{__}{{\tiny\_\_}}2,%
   morestring=[d]",
   showstringspaces=false,
   escapeinside=!!,
  }
%----------------------------------------------------------------------------------
%\lstdefinelanguage[domains]{Coq}{
%  deletekeywords={Axiom},
%  basicstyle=\small\slshape,
%}
%\lstset{language=Coq}


\lstnewenvironment{lstcoq}{\lstset{language=Coq}}{}
\newcommand{\coqinl}[1]{\lstinline[language=Coq]{#1}}

\lstnewenvironment{lstjafun}{\lstset{language=Jafun}}{}
\newcommand{\jainl}[1]{\lstinline[language=Jafun]{#1}}



% koniec definicji

\begin{document}

\maketitle

%tu idzie streszczenie na strone poczatkowa
\begin{abstract}
  W~pracy zdefiniowano logikę separacji dla języka Jafun, przedstawiono jej formalizację
  w~systemie Coq i~~udowoniono jej poprawność względem semantyki języka. Logika separacji pozwala
  na~podział sterty na rozłączne fragmenty. Upraszcza to~wnioskowanie o~programach, pozwalając
  na~dowodzenie własności podwyrażeń na~prostszych fragmentach sterty.
\end{abstract}

\tableofcontents
%\listoffigures
%\listoftablesC1 1 A

\chapter*{Wprowadzenie}
\addcontentsline{toc}{chapter}{Wprowadzenie}

\chapter{Podstawowe pojęcia i definicje}

\chapter{Jafun}

Jafun to~zorientowany obiektowo język programowania podobny do Javy.
Jego szczegółowy opis znajduje się w pracy \cite{jafun-def}.
Poniżej przedstawiam te aspekty języka, które są istotne dla prezentowanej logiki.


\section{Składnia i semantyka}

\begin{figure}[h]
$$
 \begin{array}{@{}r@{\,}l@{\;\;}c@{\;\;}l@{}}
    \Prog\owns
    & \mathbf{C}          & ::= & \jclass\;
                       C_1\; \jext\; C_2\; \boldsymbol\{ \overline{\mathbf{F}}~ \overline{\mathbf{M}} \boldsymbol\}\\
    \Cname\owns
    & C          & ::= & \langle \textit{identifier}\rangle \quad\textit{(class name)}\\
    & \mathbf{F}         & ::= & \fmodifier\; C\; x\\
    & \fmodifier & ::= & \rep\;|\; \reg \\
    \Ident\owns
    & x          & ::= & \langle \textit{identifier}\rangle \quad\textit{(variable/field name)}\\
    & \argone    & ::= & \mmod\; C\; x \qquad
      \argonen   ~\, ::=  \reg\; C\; x\\
    & \Ex        & ::= & \mmod\; C\qquad\quad
      \Exn        ::=  \reg\; C\\
    & \mathbf{M}         & ::= & \mmod\; C\; \mmod\; m(\args)\; \throws\; \Exc\;
                         \boldsymbol{\{}E\boldsymbol{\}}\;|\; \\
    &            &     & \reg\; C\; \reg\; m(\argns)\; \throws\; \Excn\; \boldsymbol{\{}E\boldsymbol{\}}\; \\
    \Lannot\owns
    & \mmod & ::= & \ls\;|\; \lenv\;|\; \bb\\
    \MIdent\owns
    & m          & ::= & \langle \textit{identifier}\rangle \quad\textit{(method name)}\\
    \Expr\owns 
    & E          & ::= & \newin{\mmod}{C}{\varrefs}\;|\; \letin{C}{x}{E_1}{E_2} |\\
    &            &     & \ite{\varref_1 == \varref_2}{E_3}{E_4}\;\;|\;                          \varref.m( \varrefs)\;|\; \\
    &            &     & \fieldref = \varref\;|\; 
                         \varref\;\;|\;                          \fieldref\;|\;                          \throwin{\varref}\;|\; \\
    &            &     & \tcatch{E_1}{\mmod\; C}{x}{E_2} \\
    \multicolumn{2}{r}{\varref\,}    & ::= & x\;|\; \jthis\;|\; \jnull \\
    \multicolumn{2}{r}{\fieldref\,}  & ::= & \varref.x 
    \\[1ex]                                         
      & A      & ::= & C\;|\; \emptyset\\
    \BCtxt\owns
      & \ctxt     & ::= &
                     \[ ~\] _A\;|\; \letin{C}{x}{\ctxt}{E}\;\;|\; \\
      &        &     &   \tcatch{\ctxt}{\mmod\; C}{x}{E}
  \end{array}
$$
\caption{Składnia języka Jafun}
\label{fig:jafun_syntax}
\end{figure}

\begin{figure}[h]
\begin{tabular}{@{}ll@{}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dsrul{newk}
&

$%
%
%
 \overline{\mathbf{C}}, h,  \overline{\ctxt}:: \ctxt\[ \newin{\mmod}{C}{l_1,\ldots,l_k}\] _\emptyset \rightarrow h'', \overline{\ctxt}:: \ctxt\[ l_0\] _\emptyset$
\\
\multicolumn{2}{l}{\qquad gdzie
$%
%
%
%
%
\alloc(h, \overline{\ctxt}, C)=(l_0, h'),\;
\fields(C) = x_1, \dots, x_k,\;
o=\emptyclass{C}\{x_1 \mapsto  l_1,\ldots,x_k \mapsto  l_k\}, \;$} \\

\multicolumn{2}{l}{\qquad \phantom{gdzie} $h'' = h'\{l_0 \mapsto  o\}$}\\[2ex]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dsrul{letin}
&
$%
%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ \letin{C}{x}{E_1}{E_2}\] _\emptyset\rightarrow h, \overline{\ctxt}:: \ctxt[\letin{C}{x}{\[ E_1\] _\emptyset}{E_2}]$
\\
\dsrul{letgo}
&
$%
%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt[\letin{C}{x}{\[ l\] _\emptyset}{E}]\rightarrow h, \overline{\ctxt}:: \ctxt\[ E\{l/x\}\] _\emptyset$
\\[2ex]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dsrul{ifeq} 
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ \ite{ l_0 == l_1}{E_1}{E_2}\] _\emptyset\! \rightarrow \!h, \overline{\ctxt}:: \ctxt\[ E_1\] _\emptyset$
\quad gdzie
$l_0=l_1$
\\
\dsrul{ifneq}
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ \ite{ l_0 == l_1}{E_1}{E_2}\] _\emptyset\! \rightarrow \!h, \overline{\ctxt}:: \ctxt\[ E_2\] _\emptyset$
\quad gdzie
$l_0\not=l_1$
\\[2ex]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dsrul{mthdnpe}
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ \jnull.m( \overline{l})\] _\emptyset \rightarrow h, \overline{\ctxt}:: \ctxt\[ \npe\] _\npetype$
\\
\dsrul{mthd}
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ l.m(\overline{l})\] _\emptyset \rightarrow h, \overline{\ctxt}:: \ctxt\[ l.m(\overline{l})\] _\emptyset::\[ E\] _\emptyset$
\\
\multicolumn{2}{l}{\qquad gdzie
$%
%
%
%
 \classof(h, l)=D, \body(D, m)=E_0, E = E_0\{l/\jthis, \overline{l}/\paramNames(D, m)\} $
}
\\[1ex]
\dsrul{mthdret}
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ l.m(\overline{l})\] _\emptyset::\[ l'\] _\emptyset \rightarrow h, \overline{\ctxt}:: \ctxt\[ l'\] _\emptyset$
\\[2ex]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dsrul{assignnpe}
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ \jnull.x = l\] _\emptyset \rightarrow h, \overline{\ctxt}:: \ctxt\[ \npe\] _\npetype$
\\
\dsrul{assignev}
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ l_1.x = l\] _\emptyset \rightarrow h', \overline{\ctxt}:: \ctxt\[ l\] _\emptyset$
%\\
%\multicolumn{2}{l}{
\qquad gdzie
$ l_1 \neq \jnull, o = h(l_1)\{x \mapsto  l\}, h' = h\{l_1 \mapsto  o\} $
%}
\\[2ex]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dsrul{varnpe}
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ \jnull.x\] _\emptyset \rightarrow h, \overline{\ctxt}:: \ctxt\[ \npe\] _\npetype$
\\
\dsrul{var}
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ l.x\] _\emptyset \rightarrow h, \overline{\ctxt}:: \ctxt\[ l'\] _\emptyset$
\qquad gdzie
$ l\not=\jnull,    l'=h(l)(x) $
\\[2ex]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dsrul{thrownull}
&
$%
%
%
%
%
\overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ \throwin{\jnull}\] _\emptyset \rightarrow h, \overline{\ctxt}:: \ctxt\[ \npe\] _{\npetype}$
\\[2ex]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dsrul{throw}
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ \throwin{l}\] _\emptyset \rightarrow h, \overline{\ctxt}:: \ctxt\[ l\] _{D}$
\qquad gdzie
$l\not=\jnull,    \classof(h, l) = D$
\\[2ex]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dsrul{ctchin}
&
$%
%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ \tcatch{E_1}{\mmod\; C}{x}{E_2}\] _\emptyset \rightarrow  
h, \overline{\ctxt}:: \ctxt[\tcatch{\[ E_1\] _\emptyset}{\mmod\; C}{x}{E_2}] $
\\
\dsrul{ctchnrml}
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt[\tcatch{\[ l\] _\emptyset}{\mmod\; C}{x}{E_2}] \rightarrow h, \overline{\ctxt}:: \ctxt\[ l\] _\emptyset$
\\
\dsrul{ctchexok}
&
$%
%
%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt[\tcatch{\[ l\] _{C'}}{\mmod\; C}{x}{E_2}] \rightarrow h, \overline{\ctxt}:: \ctxt\[ E_2'\] _\emptyset$
\qquad gdzie
$E_2' = E_2\{l/x\}, C' \leq:  C $
%}
\\[2ex]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\dsrul{letex}
&
$%
%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt[\letin{C}{x}{\[ l\] _{C'}}{E}]\rightarrow h, \overline{\ctxt}:: \ctxt\[ l\] _{C'}$
\qquad gdzie
$C'\not=\emptyset$  
\\
\dsrul{methodex}
&
$%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt\[ l.m(\overline{l})\] _\emptyset::\[ l'\] _C \rightarrow h, \overline{\ctxt}:: \ctxt\[ l'\] _C$
\qquad gdzie
$C\not=\emptyset$  
\\
\dsrul{ctchexnok}
&
$%
%
%
%
%
 \overline{\mathbf{C}}, h, \overline{\ctxt}:: \ctxt[\tcatch{\[ l\] _{C'}}{\mmod\; C}{x}{E_2}] \rightarrow h, \overline{\ctxt}:: \ctxt\[ l\] _{C'}$
\qquad gdzie
$C'\not=\emptyset, C' \not\!\leq:  C $  
%}
\\[3ex]
\end{tabular}
\caption{Semantyka języka Jafun}
\label{fig:jafun_syntax}
\end{figure}


\section{Ewaluacja}
Ewaluacją konfiguracji $(h, st)$ będziemy nazywać dowolny ciąg par $\mathit{confs} = (h_1, st_1), \ldots, (h_n, st_n)$, taki że
$h_1 = h$, $st_1 = st$ oraz $(h_i, st_i) \rightarrow (h_{i+1}, st_{i+1})$ dla $1 \leq i < n$.

Ewaluacją wyrażenia $e$ na stercie $h$ będziemy nazywać taką ewaluację konfiguracji $(h, \[ e \]_\phi)$,
że $st_n = \[ l \]_A$ dla pewnych $l, A$. Jeśli taka ewaluacja istnieje, będziemy to oznaczać jako
$(h, e) \eval{confs} (h_n, A, l)$

\chapter{Składnia i semantyka}
Prezentowana logika separacji dla języka Jafun jest logiką z~kwantyfikatorami egzystencjalnymi pierwszego rzędu, trójkami Hoare'a, operatorem $\hookrightarrow$,
pozwalającym na opisywanie zawartości sterty i~operatorami separacji $*$ i $\wand$.

Iris, na~którym wzorowana jest niniejsza logika, jest afiniczną logiką separacyjną, to~znaczy
własność spełniania termu przez stertę jest domknięta ze względu na rozszerzanie sterty.
W celu zachowania zarówno afiniczności, jak i~poprawności względem semantyki
języka, prezentowana logika nie zawiera kwantyfikatora ogólnego,
a kwantyfikator egzystencjalny jest ograniczony
do~termów najwyższego poziomu (Rysunek \ref{fig:syntax}).

Używane będzie także oznaczenie $v_1 \neq v_2$ jako skrót dla $v_1 = v_2 \Rightarrow \mathtt{False}$.

\begin{figure}[h]
\begin{align*}
 \outerP ::= & \ \exists x : C.\outerP \| \outerP \wedge \outerP \| \outerP \vee \outerP \| P \\
 P ::= & \ \mathtt{True} \| \mathtt{False} \| P \wedge P \| P \vee P \| P \Rightarrow P \| v = v \| \\
     & \  v \hookrightarrow x = v \| \hoare{P}{e}{A}{x}{P} \|  P * P \| P \wand P \\
 v ::= & \  x \| \mathtt{null} \| \mathtt{this} \\
 A ::= & \ C \| \phi \\
 x ::= & \ \langle\mathit{identifier}\rangle \ (\mathit{variable / field\ name}) \\
 C ::= & \ \langle\mathit{identifier}\rangle \ (\mathit{class\ name}) \\
 e ::= & \ \langle \mathit{Jafun\ expression} \rangle
\end{align*}
\caption{Składnia logiki}
\label{fig:syntax}
\end{figure}

Środowisko to~funkcja częściowa przypisująca identyfikatorom lokacje na stercie lub \texttt{null}.
Semantyka logiki (Rysunek \ref{fig:sematics}) jest standardowa dla kwantyfikatora i operatorów logicznych.
Dla uproszczenia zapisu notacja $\[ \cdot \]$ została użyta do~opisu semantyki obu poziomów termów
($\outerP$ i $P$). To, do którego poziomu się odnosi, wynika z kontekstu.

Sterta spełnia trójkę Hoare'a $\hoare{P}{e}{A}{x}{Q}$, jeśli dla~każdej sterty spełniającej
$P$, wyrażenie $e$ zostanie obliczone bez błędu, zwróci wyjątek typu $A$ (czyli być może żaden),
a~wynikowa sterta będzie
spełniała $Q$, w którym za~$x$~podstawiony zostanie wynik obliczenia.

Sterta spełnia term $P * Q$, jeśli można ją podzielić na dwa rozłączne fragmenty, z których
jeden spełnia $P$, a drugi $Q$.
Operator $\wand$ to pewnego rodzaju odwrotność operatora $*$ -- sterta spełnia $P \wand Q$, jeśli
po połączeniu jej z dowolną rozłączną stertą spełniającą $P$, otrzymana sterta spełnia $Q$.

\begin{figure}
\begin{align*}
 \[ \texttt{True} \] \triangleq & \ \top \\
 \[ \texttt{False} \] \triangleq & \ \bot \\
 \[ \exists x : C . P \]_{h, env} \triangleq & \ \exists l : Loc\ .\ class(h, l) = C \wedge
    \[ P \]_{h, env[x \mapsto l]}  \\
 \[ P \wedge Q \]_{h, env} \triangleq & \ \[ P \]_{h, env} \wedge \[ Q \]_{h, env} \\
 \[ P \vee Q \]_{h, env} \triangleq & \ \[ P \]_{h, env} \vee \[ Q \]_{h, env} \\
 \[ P \Rightarrow Q \]_{h, env} \triangleq & \ \[ P \]_{h, env} \Rightarrow \[ Q \]_{h, env} \\
 % TODO this
 \[ x = y \]_{h, env} \triangleq & \ env(x) = env(y) \\
 \[ x \hookrightarrow f = y \]_{h, env} \triangleq & \ h(env(x))(f) = env(y) \\
 \[ \hoare{P}{e}{A}{x}{Q} \]_{h, env} \triangleq & \forall h : Heap \ . \ \[ P \]_{h, env} \Rightarrow \\
      & \ \  \exists h' : Heap, l : Loc \ . \ (h, e[/env]) \leadsto (h', A, l) \wedge
      \[ Q \]_{h', env[x \mapsto l]}  \\
 \[ P * Q \]_{h, env} \triangleq & \ \exists h_1,h_2 : Heap\ .\ h_1 \oplus h_2 = h \wedge
    \[ P \]_{h_1, env} \wedge \[ Q \]_{h2_, env}  \\
 \[ P \wand Q \]_{h, env} \triangleq & \forall h' : Heap \ . \ \[ P \]_{h', env} \Rightarrow \[ Q \]_{h \oplus h', env}
\end{align*}

Uwaga: $e[/env]$ oznacza wyrażenie powstałe przez~podstawienie $env[x]$ w~miejsce $x$ dla~każdej zmiennej
wolnej $x$ w~$e$.

\caption{Semantyka logiki}
\label{fig:sematics}
\end{figure}

\chapter{Reguły wnioskowania}
Osądy w prezentowanej logice są postaci $\Gamma | P \vdash Q$, gdzie $\Gamma$ to środowisko typów,
przypisujące zmiennym odpowiadające im typy (czyli nazwy klas), a $P$ i $Q$ to termy logiki.
Intuicyjnie, osąd $\Gamma | P \vdash Q$ oznacza że $Q$ wynika z $P$, a więc że każda sterta spełniająca
$P$ spełnia też $Q$.

Dla poprawienia czytelności, jeśli $\Gamma$ jest wspólne dla wszystkich osądów występujących
w danej regule, to jest ono pomijane.

% TODO założenie o otypowaniu P i Q


\begin{figure}[h]
\begin{center}
\AxiomC{\phantom{$Q$}}
\prooflabel{Asm}
\UnaryInfC{$P \vdash P$}
\DisplayProof
\hskip 2em
\AxiomC{$P \vdash Q$}
\AxiomC{$Q \vdash R$}
\prooflabel{Trans}
\BinaryInfC{$P \vdash R$}
\DisplayProof
\hskip 2em
\AxiomC{\phantom{$Q$}}
\prooflabel{Eq-refl}
\UnaryInfC{$P \vdash v = v$}
\DisplayProof
\hskip 2em
\AxiomC{$P \vdash v = w$}
\prooflabel{Eq-sym}
\UnaryInfC{$P \vdash w = v$}
\DisplayProof

\vskip 2em

\AxiomC{$P \vdash \mathtt{False}$}
\prooflabel{$\bot$E}
\UnaryInfC{$P \vdash Q$}
\DisplayProof
\hskip 2em
\AxiomC{\phantom{$Q$}}
\prooflabel{$\top$I}
\UnaryInfC{$P \vdash \mathtt{True}$}
\DisplayProof
\hskip 2em
\AxiomC{$R \vdash P$}
\AxiomC{$R \vdash Q$}
\prooflabel{$\wedge$I}
\BinaryInfC{$R \vdash P \wedge Q$}
\DisplayProof
\hskip 2em
\AxiomC{$R \vdash P \wedge Q$}
\prooflabel{$\wedge$EL}
\UnaryInfC{$R \vdash P$}
\DisplayProof

\vskip 2em

\AxiomC{$R \vdash P \wedge Q$}
\prooflabel{$\wedge$ER}
\UnaryInfC{$R \vdash Q$}
\DisplayProof
\hskip 2em
\AxiomC{$R \vdash P$}
\prooflabel{$\vee$IL}
\UnaryInfC{$R \vdash P \vee Q$}
\DisplayProof
\hskip 2em
\AxiomC{$R \vdash Q$}
\prooflabel{$\vee$IR}
\UnaryInfC{$R \vdash P \vee Q$}
\DisplayProof

\vskip 2em

\AxiomC{$S \vdash P \vee Q$}
\AxiomC{$P \vdash R$}
\AxiomC{$Q \vdash R$}
\prooflabel{$\vee$E}
\TrinaryInfC{$S \vdash R$}
\DisplayProof
\hskip 2em
\AxiomC{$R \wedge P \vdash Q$}
\prooflabel{$\Rightarrow$I}
\UnaryInfC{$R \vdash P \Rightarrow Q$}
\DisplayProof
\hskip 2em
\AxiomC{$R \vdash P \Rightarrow Q$}
\AxiomC{$R \vdash P$}
\prooflabel{$\Rightarrow$E}
\BinaryInfC{$R \vdash P \Rightarrow Q$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma, x : C | Q \vdash P[t / x]$}
\prooflabel{$\exists$I}
\UnaryInfC{$Q \vdash \exists x : C . P$}
\DisplayProof
\hskip 2em
\AxiomC{$\Gamma | R \vdash \exists x : C .  P$}
\AxiomC{$\Gamma, x : C | R \wedge P \vdash Q$}
\prooflabel{$\exists$E}
\BinaryInfC{$\Gamma  | R \vdash Q$}
\DisplayProof
\end{center}
\caption{Reguły wnioskowania dla tradycyjnych operatorów logicznych}
\end{figure}

\begin{figure}[h]
\begin{center}
\AxiomC{\phantom{$Q$}}
\prooflabel{Weak}
\UnaryInfC{$P * Q \vdash P$}
\DisplayProof
\hskip 2em
\AxiomC{\phantom{$Q$}}
\prooflabel{Sep-assoc}
\UnaryInfC{$P * (Q * R) \dashv\vdash (P * Q) * R$}
\DisplayProof
\hskip 2em
\AxiomC{\phantom{$Q$}}
\prooflabel{Sep-sym}
\UnaryInfC{$P * Q \vdash Q * P$}
\DisplayProof

\vskip 2em

\AxiomC{$P_1 \vdash Q_1$}
\AxiomC{$P_2 \vdash Q_2$}
\prooflabel{$*$I}
\BinaryInfC{$P_1 * Q_1 \vdash P_2 * Q_2$}
\DisplayProof
\hskip 2em
\AxiomC{$R * P \vdash Q$}
\prooflabel{$\wand$I}
\UnaryInfC{$R \vdash P \wand Q$}
\DisplayProof
\hskip 2em
\AxiomC{$R_1 \vdash P \wand Q$}
\AxiomC{$R_2 \vdash P$}
\prooflabel{$\wand$E}
\BinaryInfC{$R_1 * R_2 \vdash Q$}
\DisplayProof
\end{center}
\caption{Reguły wnioskowania dla operatorów separacyjnych}
\end{figure}


\begin{figure}
\begin{center}
\textbf{Reguły strukturalne dla trójek Hoare'a}

\vskip 2em

\AxiomC{$S \vdash \hoare{P}{e}{A}{v}{Q}$}
\AxiomC{$S$ jest trwały}
\prooflabel{Ht-frame}
\BinaryInfC{$S \vdash \hoare{P * R}{e}{A}{v}{Q * R}$}
\DisplayProof
\hskip 2em
\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-ret}
\UnaryInfC{$S \vdash \hoare{\mathtt{True}}{w}{\phi}{v}{v = w}$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma | S \vdash P \Rightarrow P'$}
\AxiomC{$\Gamma | S \vdash \hoare{P'}{e}{A}{v}{Q'}$}
\AxiomC{$\Gamma, v : C | S \vdash Q' \Rightarrow Q$}
\AxiomC{$S$ jest trwały}
\prooflabel{Ht-csq}
\QuaternaryInfC{$S \vdash \hoare{P}{e}{A}{v}{Q}$}
\DisplayProof

\vskip 2em

\AxiomC{$S \vdash \hoare{P}{e}{A}{v}{Q}$}
\AxiomC{$S \vdash \hoare{Q}{e}{A}{v}{Q}$}
\prooflabel{Ht-disj}
\BinaryInfC{$S \vdash \hoare{P \vee Q}{e}{A}{v}{Q}$}
\DisplayProof

\vskip 2em

\AxiomC{$S \wedge R \vdash \hoare{Q}{e}{A}{v}{Q}$}
\prooflabel{Ht-pers}
\RightLabel{jeśli R trwały}
\doubleLine
\UnaryInfC{$S \vdash \hoare{Q \wedge R}{e}{A}{v}{Q}$}
\DisplayProof

\vskip 2em

\textbf{Reguły dla trójek Hoare'a opisujących konstrukcje języka}

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-new-null}
\UnaryInfC{$S \vdash \hoare{\mathtt{True}}{\mathbf{new} \ C(\overline{v})}{\phi}{w}{w \neq \mathbf{null}}$}
\DisplayProof

\vskip 2em

\AxiomC{$\mathrm{flds}(C) = f_1, \ldots, f_n$}
\prooflabel{Ht-new-field}
\UnaryInfC{$S \vdash \hoare{\mathtt{True}}{\mathbf{new} \ C(v_1, \ldots, v_n)}{\phi}{w}{w \hookrightarrow f_i = v_i}$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma | S \vdash \hoare{P}{E_1}{\phi}{x}{Q}$}
\AxiomC{$\Gamma, x : C | S \vdash \hoare{Q}{E_2}{A}{w}{R}$}
\prooflabel{Ht-let}
\RightLabel{jeśli S trwały}
\BinaryInfC{$\Gamma | S \vdash \hoare{P}{\mathbf{let} \ C \ x = E_1 \ \mathbf{in} \ E_2}{A}{w}{R}$}
\DisplayProof

\vskip 2em

\AxiomC{$S \vdash \hoare{P}{E_1}{A}{w}{Q}$}
\AxiomC{$A \neq \phi$}
\prooflabel{Ht-let-ex}
\BinaryInfC{$\Gamma | S \vdash \hoare{P}{\mathbf{let} \ C \ x = E_1 \ \mathbf{in} \ E_2}{A}{w}{Q}$}
\DisplayProof

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-field-set}
\UnaryInfC{$S \vdash \hoare{x \neq \mathtt{null}}{x.f = v}{\phi}{\_}{x \hookrightarrow f = v}$}
\DisplayProof

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-null-set}
\UnaryInfC{$S \vdash \hoare{x = \mathtt{null}}{x.f = v}{\mathtt{NPE}}{w}{w = \mathtt{npe}}$}
\DisplayProof

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-field-get}
\UnaryInfC{$S \vdash \hoare{x \hookrightarrow f = v}{x.f}{\phi}{w}{w = v}$}
\DisplayProof

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-null-get}
\UnaryInfC{$S \vdash \hoare{x = \mathtt{null}}{x.f}{\mathtt{NPE}}{w}{w = \mathtt{npe}}$}
\DisplayProof
\end{center}
\caption{Reguły wnioskowania dla trójek Hoare'a}
\end{figure}


\begin{figure}
\begin{center}
\AxiomC{$S \vdash \hoare{P \wedge v_1 = v_2}{E_1}{A}{w}{Q}$}
\AxiomC{$S \vdash \hoare{P \wedge v_1 \neq v_2}{E_2}{A}{w}{Q}$}
\prooflabel{Ht-if}
\BinaryInfC{$S \vdash \hoare{P}{\mathbf{if} \ v_1 = v_2 \ \mathbf{then} \ E_1 \ \mathbf{else} \ E_2}{A}{w}{Q}$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma \vdash x : C$}
\AxiomC{$\hoare{P'}{\cdot}{A}{w}{Q'} \in \mathtt{invariants}(C, m)$}
\noLine
\UnaryInfC{$S \wedge \hoare{P'}{x.m(\overline{v})}{A}{w}{Q'} \vdash \hoare{P}{x.m(\overline{v})}{A}{w}{Q}$}
\prooflabel{Ht-invoke}
\BinaryInfC{$S \vdash \hoare{P}{x.m(\overline{v})}{A}{w}{Q}$}
\DisplayProof

\vskip 2em


\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-null-invoke}
\UnaryInfC{$S \vdash \hoare{x = \mathtt{null}}{x.m(\overline{v})}{\mathtt{NPE}}{w}{w = \mathtt{npe}}$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma \vdash x : C$}
\prooflabel{Ht-throw}
\UnaryInfC{$S \vdash \hoare{x \neq \mathtt{null}}{\mathbf{throw} \ x}{C}{w}{w = x}$}
\DisplayProof

\vskip 2em

\AxiomC{\phantom{$Q$}}
\prooflabel{Ht-null-throw}
\UnaryInfC{$S \vdash \hoare{x = \mathtt{null}}{\mathbf{throw} \ x}{\mathtt{NPE}}{w}{w = \mathtt{npe}}$}
\DisplayProof

\vskip 2em

\AxiomC{$S \vdash \hoare{P}{E_1}{\phi}{w}{Q}$}
\prooflabel{Ht-catch-normal}
\UnaryInfC{$S \vdash \hoare{P}{\mathbf{try} \ E_1 \ \mathbf{catch} \ (C \ x) \ E_2}{\phi}{w}{Q}$}
\DisplayProof

\vskip 2em

\AxiomC{$\Gamma | S \vdash \hoare{P}{E_1}{C'}{x}{Q}$}
\AxiomC{$\Gamma, x : C' | S \vdash \hoare{Q}{E_2}{A}{w}{R}$}
\AxiomC{$C' \leq C$}
\prooflabel{Ht-catch-ex}
\RightLabel{jeśli S trwały}
\TrinaryInfC{$\Gamma | S \vdash \hoare{P}{\mathbf{try} \ E_1 \ \mathbf{catch} \ (C \ x) \ E_2}{A}{w}{R}$}
\DisplayProof

\vskip 2em

\AxiomC{$S \vdash \hoare{P}{E_1}{C'}{w}{Q}$}
\AxiomC{$C' \not\leq C$}
\prooflabel{Ht-catch-pass}
\BinaryInfC{$S \vdash \hoare{P}{\mathbf{try} \ E_1 \ \mathbf{catch} \ (C \ x) \ E_2}{C'}{w}{Q}$}
\DisplayProof


\caption{Reguły wnioskowania dla trójek Hoare'a - c.d.}
\end{center}
\end{figure}



\chapter{Własności ewaluacji}
Pokażę teraz twierdzenia o własności ewaluacji, które będą później użyte do udowodnienia poprawności reguł dla trójek Hoare'a.
\section{Łączenie ewaluacji}
Podatwowym twierdzeniem, pozwalającym mówić o ewaluacji złożonych wyrażeń, jest twierdzenie o łączeniu ewaluacji.
\begin{theorem}[O łączeniu ewaluacji]
Niech $(h, st), (h', st'), (h'', st'')$ będą konfiguracjami, a $confs$ i $confs'$ -- ciągami konfiguracji,
takimi że $(h, st) \eval{confs} (h', st')$ i $(h', st') \eval{confs'} (h'', st'')$.
Wtedy $(h, st) \eval{confs ++ confs'} (h'', st'')$.
\end{theorem}
\begin{proof}
TODO
\end{proof}

\section{Ewaluacja przy rozszerzonym stosie i kontekście}

\section{Ewaluacja zależy tylko od zmiennych wolnych}
Twierdzenie o zależności ewaluacji od zmiennych wolnych jest kluczowe w dowodzie poprawności dla
reguł \textsc{Weak} i \textsc{Ht-frame}.
Mówi ono, że jeśli dwie sterty zgadzają się na lokacjach odpowiadających zmiennym wolnym w pewnym wyrażeniu $E$,
to ewaluacje wyrażenia $E$ na tych dwóch stertach będą w pewnym sensie równoważne.

Równoważnośc ta nie będzie niestety trywialna, bo nowo zaalokowane lokacje na obu sterach mogą się różnić.
Zgodnie z semantyką języka, lokacja zwracana przez operator \textbf{new} to (maximum z lokacji na stercie) + 1.
Stąd, ponieważ nie zakładamy niczego o lokacjach innych niż te odpowiadające zmiennym wolnym,
wartość zwracana przez operator \textbf{new} może się różnić pomiędzy stertami.
Nowo zaalokowane lokacje mogą następnie zostać zapisane w polach obiektów znajdujących się pod lokacjami
odpowiadającymi zmiennym wolnym, co oznacza że nawet te obiekty, początkowo równe na obu stertach,
mogą zacząć się różnić w czasie ewaluacji.

Żeby obejść ten problem, zdefiniujemy \textit{izomorfizm stert} jako bijekcję między lokacjami
na tych stertach,
zachowującą \texttt{null} i kompozycję.

\begin{definition}[izomorfizm stert] {\ } \\
Niech $h_1, h_2 : \mathsf{Heap}$.
Funkcję $f : \mathrm{Dom}(h_1) \cup \{\mathtt{null}\} \to \mathrm{Dom}(h_2) \cup \{\mathtt{null}\}$
nazwiemy izomorfizmem między tymi stertami, jeśli:
\begin{enumerate}
 \item $f$ jest bijekcją
 \item $f(\mathtt{null}) = \mathtt{null}$
 \item $f$ zachowuje kompozycję, to znaczy dla dowolnych lokacji $l_1, l_2$ i pola $x$ zachodzi
    $$h_1(l_1) \hookrightarrow x = l_2 \iff h_2(f(l_2)) \hookrightarrow x = f(l_2)$$
\end{enumerate}
Jeśli taka funkcja $f$ istnieje, powiemy że sterty $h_1$ i $h_2$ są izomorficzne.
\qed
\end{definition}

Ostatecznie będziemy chcieli pokazać, że jeśli wyrażenie $E$ nie zawiera zmiennych wolnych,
a sterty $h_1, h_2$ są równe na wszystkich lokacjach występujących w $E$, to
ewaluacje $E$ na stertach $h_1$ i $h_2$ są równoważne z dokładnością do izomorfizmu.

To oznacza, że potrzebujemy mówić o izomorfizmach konfiguracji (czyli ciągów par (sterta, stos wywołań)),
a zatem należy zdefiniować także izomorfizmy między stosami wywołań.
Służy temu kolejnych kilka definicji.


\chapter{Poprawność}

\chapter{Formalizacja w systemie Coq}

\chapter{Podsumowanie}

\appendix
\begin{thebibliography}{99}
\addcontentsline{toc}{chapter}{Bibliografia}

\bibitem {jafun-def} J. Chrząszcz and A. Schubert. Function definitions for compound values in object-
oriented languages. In \textit{Proc. of the 19th International Symposium on Principles
and Practice of Declarative Programming}, PPDP ’17, pp. 61–72. ACM, 2017.

\bibitem {jafun-sem} J. Chrząszcz and A.Schubert. Formalisation of a frame stack semantics for a Java-like language. 2018

\end{thebibliography}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% coding: latin-2
%%% End:
